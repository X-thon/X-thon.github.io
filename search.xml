<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>爬虫练习-爬取豆瓣电影某剧剧照</title>
    <url>/posts/27429/</url>
    <content><![CDATA[<!-- build time:Fri Apr 24 2020 22:36:20 GMT+0800 (中国标准时间) --><p>很惭愧……不知道自己时间都去哪了，今天才发现文件夹里好多写了一半的文章，想把它们补完，一下子又没什么头绪接着写……啊啊啊((٩(//̀Д/́/)۶)) 算了重新写一篇记录一下第一个爬虫练习项目吧～</p><p>话不多说，开始吧！</p><a id="more"></a><h2 id="爬取目标"><a href="#爬取目标" class="headerlink" title="爬取目标"></a>爬取目标</h2><p>目标是豆瓣电影栏里《逃跑虽可耻但有用》的剧照<del>（Gakki）</del></p><p>看了一下，一共是3268张照片 (╯‵□′)╯︵┻━┻ 身为小白的我一下子就慌了</p><p><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-17-114038.png" alt="不信你看"></p><p><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-17-114037.jpg" alt="四倍憋屈"></p><p>好好我先冷静一下，想想啊，为了……(｡･∀･)ﾉﾞ怎么也要试一下</p><p><a href="https://movie.douban.com/subject/26816519/photos?type=S&start=0&sortby=time&size=a&subtype=a" target="_blank" rel="noopener">目标网址</a>在此！（我选择了按时间排序）</p><h2 id="爬取思路"><a href="#爬取思路" class="headerlink" title="爬取思路"></a>爬取思路</h2><p>我既然要爬，当然是选择爬高清原图啦！爬小图标算怎么回事呢？打开控制台浏览了一下，到达原图的过程大概是这样的：</p><p>首先点击小图标进入普通图标界面，在普通图标界面点击”查看原图”，然后就可以看到我惦记着的高清原图啦！</p><p>所以，爬虫的大概思路就有啦，如下：</p><p><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-17-114039.png" alt="gakki大作战流程图1.0.0"></p><h2 id="爬取小图标页面上所有进入普通图标的链接"><a href="#爬取小图标页面上所有进入普通图标的链接" class="headerlink" title="爬取小图标页面上所有进入普通图标的链接"></a>爬取小图标页面上所有进入普通图标的链接</h2><p>由下图可以看见，进入普通图标的链接就在 <a>标签中：</a></p><p><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-17-114040.png" alt="普通图标链接示例"></p><p>所以，只要这样：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re  <span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">url = <span class="string">"https://movie.douban.com/subject/26816519/photos?type=S&amp;start=0&amp;sortby=time&amp;size=a&amp;subtype=a"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawl_all_normal_link</span><span class="params">(current_link)</span>:</span></span><br><span class="line">    response = requests.get(url).text</span><br><span class="line">    html = BeautifulSoup(response, <span class="string">"html.parser"</span>)</span><br><span class="line">    link_list_seed = html.findAll(<span class="string">"a"</span>,&#123;<span class="string">"href"</span>:re.compile(<span class="string">"https://movie.douban.com/photos/photo/\d&#123;9&#125;$"</span>)&#125;)</span><br><span class="line">    link_list = list()      </span><br><span class="line">    <span class="keyword">for</span> temp_link <span class="keyword">in</span> link_list_seed:</span><br><span class="line">        link_list.append(temp_link[<span class="string">"href"</span>])</span><br></pre></td></tr></table></figure><p>比较懒，这里就不写进行异常处理的代码了<del>（好吧我承认我是真的懒）</del></p><h2 id="在普通图标的页面爬取高清原图的链接"><a href="#在普通图标的页面爬取高清原图的链接" class="headerlink" title="在普通图标的页面爬取高清原图的链接"></a>在普通图标的页面爬取高清原图的链接</h2><p>以下分别是普通图的链接与高清原图的链接：</p><blockquote><p><a href="https://movie.douban.com/photos/photo/2449245140/" target="_blank" rel="noopener">https://movie.douban.com/photos/photo/2449245140/</a></p><p><a href="https://img3.doubanio.com/view/photo/raw/public/p2449245140.jpg" target="_blank" rel="noopener">https://img3.doubanio.com/view/photo/raw/public/p2449245140.jpg</a></p></blockquote><p>看出不同点与共同点了吗？？这里有两种方式可以获取高清原图的链接：</p><ol><li>在小图标界面直接抓取该图片的id，也就是末尾那串数字；然后直接进行字符串拼接，得到高清原图的链接；</li><li>在普通原图的页面，将cookie写到header里进行get请求（其余必须的header信息也需要写进去）；然后利用正则表达式将符合高清原图链接的字符串抓取出来；</li></ol><p>我使用的是第二种方法，第一种方法的代码也会在后文给出；</p><p>需要注意的是，如果使用第二种方式：</p><p><strong>如果不传入cookie，使用正则匹配出来的会是一个锚链接</strong></p><p>也就是 ”#“ ，对，就是一个井号~（当时内心：“Excuse me？？？”）</p><p><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-17-114036.jpg" alt="Excuse me"></p><p>cookie需要怎么获取呢？？</p><p>很简单，在普通图标的页面登陆豆瓣之后；然后打开控制台（F12），点击Network：</p><p><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-17-114041.png" alt="Network"></p><p>刷新一下，选择下图中箭头指向的网页：</p><p><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-17-114042.png" alt="当前页面网页"></p><p>在右侧的Requests Headers就可以找到你的cookie，复制下来就行啦~</p><p>以下是实现的代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cookie = <span class="string">'''这里放你自己的cookie'''</span></span><br><span class="line"><span class="comment"># 定制请求头</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.63 (KHTML, like Gecko) Ubuntu Chromium/55.0.2883.87 Chrome/55.0.2883.87 Safari/573.36'</span>,</span><br><span class="line">    <span class="string">'Accept'</span>:<span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'</span>,</span><br><span class="line">    <span class="string">'Accept-Encoding'</span>:<span class="string">'gzip, deflate, sdch, br'</span>,</span><br><span class="line">    <span class="string">'cache-control'</span>:<span class="string">'max-age=0'</span>,</span><br><span class="line">    <span class="string">'referer'</span>:<span class="string">'https://movie.douban.com/photos/photo/2403250855/'</span>,</span><br><span class="line">    <span class="string">'Cookie'</span>:cookie    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">函数功能：从中等图标网页，爬取进入高清原图的url</span></span><br><span class="line"><span class="string">接收参数：URL(字符串类型)</span></span><br><span class="line"><span class="string">返回值：字符串</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_real_img_link</span><span class="params">(url_list)</span>:</span></span><br><span class="line">    current_html = requests.get(url_list, headers = headers, stream = <span class="literal">True</span>).text</span><br><span class="line">    current_html_trans = BeautifulSoup(current_html,<span class="string">"html.parser"</span>)</span><br><span class="line">    <span class="comment"># 注意，这儿用的是 find 不是 findAll</span></span><br><span class="line">    real_img_link_no_trans = current_html_trans.findAll(<span class="string">"a"</span>,&#123;<span class="string">"class"</span>:<span class="string">"photo-zoom"</span>&#125;)</span><br><span class="line">    real_img_link = list()</span><br><span class="line">    <span class="keyword">for</span> temp_link <span class="keyword">in</span> real_img_link_no_trans:</span><br><span class="line">        real_img_link.append(temp_link[<span class="string">"href"</span>])</span><br><span class="line">    <span class="keyword">return</span> real_img_link</span><br></pre></td></tr></table></figure><h2 id="将高清原图保存到本地"><a href="#将高清原图保存到本地" class="headerlink" title="将高清原图保存到本地"></a>将高清原图保存到本地</h2><p>我直接放代码好了：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">root = <span class="string">"E://pics//"</span>    <span class="comment">#这里根据你的需要修改路径就好了</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">函数功能：将图片保存至本地;需要预先设定好root,即存放图片的文件夹的路径</span></span><br><span class="line"><span class="string">接收参数：URL(字符串类型),无返回值</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_img</span><span class="params">(url)</span>:</span></span><br><span class="line">    response = requests.get(url, headers = headers, stream = <span class="literal">True</span>)    <span class="comment">#stream默认是True</span></span><br><span class="line">    path = root + url.split(<span class="string">'/'</span>)[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(root):</span><br><span class="line">            os.mkdir(root)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">            <span class="keyword">with</span> open(path,<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(response.content)</span><br><span class="line">                f.close</span><br><span class="line">                print(<span class="string">"文件保存成功"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"文件已经存在"</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">"爬取失败"</span>)</span><br></pre></td></tr></table></figure><h2 id="爬取下一页的链接"><a href="#爬取下一页的链接" class="headerlink" title="爬取下一页的链接"></a>爬取下一页的链接</h2><p>下面是代码👇：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">函数功能：查找下一页的链接的函数</span></span><br><span class="line"><span class="string">接收参数：URL(字符串类型)</span></span><br><span class="line"><span class="string">返回值：下一页的链接(字符串类型)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_next_link</span><span class="params">(url)</span>:</span></span><br><span class="line">    response_data = requests.get(url, headers = headers, stream = <span class="literal">True</span>).text</span><br><span class="line">    response = BeautifulSoup(response_data, <span class="string">"html.parser"</span>)</span><br><span class="line">    <span class="comment"># 需要弄清楚，不存在符合条件的标签时，.find()的返回值是什么?</span></span><br><span class="line">    next_link_no_trans = response.find(<span class="string">"link"</span>,&#123;<span class="string">"rel"</span>:<span class="string">"next"</span>&#125;)</span><br><span class="line">    next_link = next_link_no_trans[<span class="string">"href"</span>]</span><br><span class="line">    <span class="keyword">return</span> next_link</span><br></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>虽然一开始有被吓到，但是冷静下来好好思考的话还是很简单的</p><p>中间当然踩了不少坑了，诸如 <strong>403 Forbidden</strong> 之类的恼人的错误，不过解决过后还是觉得学会了不少哇，嗯咳！作为第一个练习，能完成的像这样也稍微夸夸自己好啦~</p><p>不好意思的是：自己总是来不及写博客，总是拖上个十天半个月的……</p><p><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-17-114039.jpg" alt="真叫人头大"></p><p>希望以后自己的及时学完便记吧！</p><p>内容大概就是这些啦，等我将代码整理后会把链接贴上来的吼~</p><p>白白～ ヾ(•ω•`)o</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>魔法师成长日记</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学课程的第二次实验</title>
    <url>/posts/15402/</url>
    <content><![CDATA[<!-- build time:Fri Apr 24 2020 22:36:20 GMT+0800 (中国标准时间) --><p>好多天没写博客了…..最近离散数学课程做了一个简单的实验，记录一下…(￣o￣) . z Z</p><a id="more"></a><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>对任意二元关系集合，判定其是否具有自反性、对称性、传递性、反对称性、反自反性，如果不具有某性质，需要至少输出一个反例。</p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ol><li><p>输入：</p><p>从屏幕输入集合X <strong>（不超过5个元素）</strong>上的关系<strong>（必做）</strong>；程序随机生成关系<strong>（选做）</strong>。</p></li><li><p>输出关系矩阵。</p></li><li><p>输出性质描述，不具备的性质需给出反例描述。</p></li></ol><h2 id="关系的性质"><a href="#关系的性质" class="headerlink" title="关系的性质"></a>关系的性质</h2><ul><li><strong>自反</strong>的二元关系R相应的关系矩阵主对角线元素都为1 ;</li><li><strong>反自反</strong>的二元关系R相应的关系矩阵主对角线元素都为 0 ;</li><li><strong>对称</strong>的二元关系R相应的关系矩阵也是对称的 ;</li><li><strong>反对称</strong>的二元关系R相应的关系矩阵也是反对称的(这里定义1的反为0) ;</li><li><strong>传递</strong>的二元关系R，相应的关系矩阵R中若$r_{ij}=1$ , $r_{jk}=1$ , 则$r_{ik}=1$ ;</li></ul><h2 id="自己所设计的实验步骤"><a href="#自己所设计的实验步骤" class="headerlink" title="自己所设计的实验步骤"></a>自己所设计的实验步骤</h2><ol><li>利用二维数组建图 $→$ 这就需要获取 <strong>集合X中元素的个数</strong> ;</li><li>读入集合X上的关系建图 $→$ 这就需要获取 <strong>各个关系中的序偶</strong> ;</li><li>写出用以判断各个关系性质的函数：<ul><li>自反性利用 $r_{ii}$ 是否全为1即可判断，一重for循环 ;</li><li>反自反性利用 $r_{ii}$ 是否全为0即可判断，一重for循环 ;</li><li>对称性利用转置矩阵的方法判断也可以，不过此处不用麻烦，直接判断 $r_{ij} == r_{ji} ?$ 即可，两重for循环 ;</li><li>反对称性,*<em>要么矩阵关于对角线对称的元素全为 0（即为对称阵），要么 $r_{ij} == 1 $ &amp;&amp; $ r_{ji} == 0 $ *</em> , 在两重for循环中增加条件判断即可 ;</li><li>传递性则利用 <strong>floyd算法</strong> 跑一遍图即可判断（当然直接用三重循环 + 定义判断更方便） ;</li></ul></li><li>在主函数中给出提示输入的语句及规范化输出语句即可 。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>代码有点点长…写的也比较随意，贴上去：</p><p><a href="http://paste.ubuntu.com/24417702/" target="_blank" rel="noopener">贴在这里</a></p><h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>文章就到这里，感谢你的阅读！٩(๑`^´๑)۶</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode&#39;289-554-621&#39;三题练习总结</title>
    <url>/posts/47384/</url>
    <content><![CDATA[<!-- build time:Fri Apr 24 2020 22:36:20 GMT+0800 (中国标准时间) --><p>到今天为止，在菊厂的实习就结束啦。回到宿舍后把答辩时做的题总结总结，记录在这里。</p><p>当然了，写总结的时候回想了一下，自己答辩时写的代码真丑……</p><a id="more"></a><h2 id="289-生命游戏"><a href="#289-生命游戏" class="headerlink" title="289 生命游戏"></a>289 生命游戏</h2><p>根据百度百科，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在1970年发明的细胞自动机。</p><p>题目描述：</p><blockquote><p>给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞具有一个初始状态 live（1）即为活细胞， 或 dead（0）即为死细胞。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p><p>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；<br>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；<br>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；<br>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；<br>根据当前状态，写一个函数来计算面板上细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。</p></blockquote><p>输入样例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">]</span><br><span class="line">输出: </span><br><span class="line">[</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>解决代码 ：</p><p>简单直白，完全按照题目解释做了两个循环。第一个循环用于标记，第二个循环用于赋值。<br>1——保持1<br>-1——1转0<br>0——保持0<br>-2——0转1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                board[i][j] = checkLoc(board, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                board[i][j] = board[i][j] == <span class="number">1</span> || board[i][j] == -<span class="number">2</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkLoc</span><span class="params">(<span class="keyword">int</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = Math.max(j - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> right = Math.min(j + <span class="number">1</span>, board[i].length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> top = Math.max(i - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> bottom = Math.min(i + <span class="number">1</span>, board.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = top; x &lt;= bottom; x++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y = left; y &lt;= right; y++)&#123;</span><br><span class="line">                count = board[x][y] == <span class="number">1</span> || board[x][y] == -<span class="number">1</span> ? count + <span class="number">1</span> : count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board[i][j] == <span class="number">1</span> ? (count == <span class="number">3</span> || count == <span class="number">4</span> ? <span class="number">1</span> : -<span class="number">1</span>) : (count == <span class="number">3</span> ? -<span class="number">2</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="554-砖墙"><a href="#554-砖墙" class="headerlink" title="554 砖墙"></a>554 砖墙</h2><p>题目描述：</p><blockquote><p>你的面前有一堵方形的、由多行砖块组成的砖墙。 这些砖块高度相同但是宽度不同。你现在要画一条自顶向下的、穿过最少砖块的垂线。</p><p>砖墙由行的列表表示。 每一行都是一个代表从左至右每块砖的宽度的整数列表。</p><p>如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。你需要找出怎样画才能使这条线穿过的砖块数量最少，并且返回穿过的砖块数量。</p><p>你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。</p></blockquote><p>输入样例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">      [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">      [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">      [<span class="number">2</span>,<span class="number">4</span>],</span><br><span class="line">      [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">      [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><blockquote><p>提示：</p><ol><li>每一行砖块的宽度之和应该相等，并且不能超过 INT_MAX。</li><li>每一行砖块的数量在 [1,10,000] 范围内， 墙的高度在 [1,10,000] 范围内， 总的砖块数量不超过 20,000。</li></ol></blockquote><p>解决代码1：</p><p>穿过最少砖的直线肯定是穿过缝隙最多的线，所以可以遍历整个List，获取每一行每条缝隙对应的砖宽， 将砖宽度和砖宽度出现的次数存入Map，最后遍历map获取出现次数最多的宽度，总行数-出现次数即为结果。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LeastBricks</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; wall)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span>(List&lt;Integer&gt; list : wall) &#123;</span><br><span class="line">            <span class="keyword">int</span> acc = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                acc += list.get(i);</span><br><span class="line">                map.put(acc, map.getOrDefault(acc, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : map.values()) &#123; </span><br><span class="line">            <span class="keyword">if</span> (v &gt; max) &#123;</span><br><span class="line">                max = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">return</span> wall.size() - max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="621-任务调度器"><a href="#621-任务调度器" class="headerlink" title="621 任务调度器"></a>621 任务调度器</h2><p>题目描述：</p><blockquote><p>给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。</p><p>然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p><p>你需要计算完成所有任务所需要的最短时间。</p></blockquote><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: tasks = [<span class="string">"A"</span>,<span class="string">"A"</span>,<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"B"</span>,<span class="string">"B"</span>], n = <span class="number">2</span></span><br><span class="line">输出: <span class="number">8</span></span><br><span class="line">执行顺序: A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B.</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><ol><li>任务的总个数为 [1, 10000]。</li><li>n 的取值范围为 [0, 100]。</li></ol></blockquote><p>解决代码1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> tasks.length;</span><br><span class="line">        <span class="keyword">int</span>[] number = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;tasks.length; i++)&#123;</span><br><span class="line">            number[tasks[i]-<span class="string">'A'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(number);</span><br><span class="line">        <span class="comment">//取出最大值，和最大值个数</span></span><br><span class="line">        <span class="keyword">int</span> max = number[number.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i=number.length-<span class="number">1</span>; <span class="keyword">int</span> max_len =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(number[i--]==max) max_len++;</span><br><span class="line">        <span class="comment">//A-&gt;B-&gt;X -&gt;A-&gt;B-&gt;X -&gt;A-&gt;B</span></span><br><span class="line">        <span class="comment">//A的个数-1*每一组的数（n+1）+最大值相同的个数</span></span><br><span class="line">        <span class="keyword">return</span> Math.max((max-<span class="number">1</span>)*(n+<span class="number">1</span>)+max_len,tasks.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决代码2：</p><p>解释一下这个公式怎么来的 (count[25] - 1) * (n + 1) + maxCount：</p><ol><li>假设数组 [“A”,”A”,”A”,”B”,”B”,”C”]，n = 2，A的频率最高，记为count = 3，所以两个A之间必须间隔2个任务，才能满足题意并且是最短时间（两个A的间隔大于2的总时间必然不是最短），因此执行顺序为： A-&gt;X-&gt;X-&gt;A-&gt;X-&gt;X-&gt;A，这里的X表示除了A以外其他字母，或者是待命，不用关心具体是什么，反正用来填充两个A的间隔的。上面执行顺序的规律是： 有count - 1个A，其中每个A需要搭配n个X，再加上最后一个A，所以总时间为 (count - 1) * (n + 1) + 1；</li><li>要注意可能会出现多个频率相同且都是最高的任务，比如 [“A”,”A”,”A”,”B”,”B”,”B”,”C”,”C”]，所以最后会剩下一个A和一个B，因此最后要加上频率最高的不同任务的个数 maxCount；</li><li>公式算出的值可能会比数组的长度小，如[“A”,”A”,”B”,”B”]，n = 0，此时要取数组的长度。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = tasks.length;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">1</span> || n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//得到每个字符的数量后再排序</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; len)&#123;</span><br><span class="line">            nums[tasks[i++] - <span class="number">65</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">//res的最小值</span></span><br><span class="line">        <span class="keyword">int</span> res = (nums[<span class="number">25</span>] - <span class="number">1</span>) * (n + <span class="number">1</span>);</span><br><span class="line">        i = <span class="number">25</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; nums[i] == nums[<span class="number">25</span>])&#123;</span><br><span class="line">        	<span class="comment">//若最多数量的字符有多个 则res相应地+1</span></span><br><span class="line">            res++;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到的结果为res与数组长度len之间最大值</span></span><br><span class="line">        <span class="keyword">return</span> res &gt; len ? res : len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>做题笔记</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Flak+pyenv+gunicorn+nginx+supervisor初次部署总结</title>
    <url>/posts/38635/</url>
    <content><![CDATA[<!-- build time:Fri Apr 24 2020 22:36:20 GMT+0800 (中国标准时间) --><p>在个人博客的搭建实践完成后，就剩下尝试将项目部署上线了。初次进行项目部署，踩了不少坑，在过程中浏览了不少教程和资料，然而都不甚完整，因此将自己部署过程记录下来，以做总结、参考。</p><a id="more"></a><p><strong>写在前面：</strong></p><ul><li>本篇文章，远程主机系统为<code>Ubuntu 18</code>；</li><li>使用Git进行程序部署；虚拟环境采用pyenv管理、配置，这里不进行详细说明；</li><li>关于迁移工具、日志等不进行说明；</li></ul><h2 id="安装Gunicorn、Nginx、Supervisor"><a href="#安装Gunicorn、Nginx、Supervisor" class="headerlink" title="安装Gunicorn、Nginx、Supervisor"></a>安装Gunicorn、Nginx、Supervisor</h2><p>切换到项目使用的虚拟环境下：</p><ol start="0"><li><p>安装<strong>项目依赖</strong>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pip install -r requirements.txt</span></span><br></pre></td></tr></table></figure></li><li><p>安装<strong>Gunicorn</strong>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pip install gunicorn</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果想要使用异步worker，如gevent，则需要进行安装（本次部署采用gevent运行gunicorn）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pip install gevent</span></span><br></pre></td></tr></table></figure></li><li><p>安装<strong>Nginx</strong>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第一次部署，我使用系统二进制源方式安装即可</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install nginx</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查是否安装成功</span></span><br><span class="line">nginx -v</span><br></pre></td></tr></table></figure><p>更多关于Linux下安装Nginx的内容，可以查看这篇<a href="https://juejin.im/post/5d31ec3b5188253a8f27ef5b" target="_blank" rel="noopener">博客</a>。</p></li><li><p>安装<strong>Supervisor</strong>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pip install supervisor</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="创建程序实例-入口"><a href="#创建程序实例-入口" class="headerlink" title="创建程序实例(入口)"></a>创建程序实例(入口)</h2><p>在项目根目录下创建一个名为<code>wsgi.py</code>的脚本(命名只是约定，可以使用其他名称)，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># wsgi.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> dotenv <span class="keyword">import</span> load_dotenv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入环境变量</span></span><br><span class="line">dotenv_path = os.path.join(os.path.dirname(__file__), <span class="string">'.env'</span>)</span><br><span class="line"><span class="keyword">if</span> os.path.exists(dotenv_path):</span><br><span class="line">    load_dotenv(dotenv_path, override=<span class="literal">True</span>) <span class="comment"># load_dotenv默认不会更新已经存在的配置项, 因此使用override参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> xthonblog <span class="keyword">import</span> create_app</span><br><span class="line">app = create_app(<span class="string">'production'</span>)</span><br></pre></td></tr></table></figure><p>此程序实例仅在部署时运行。如果在生产环境下，需要使用生产服务器运行程序实例时，可以从本文件导入此程序实例：<code>from wsgi import app</code> 。</p><h2 id="从Git拉取代码并初始化程序环境"><a href="#从Git拉取代码并初始化程序环境" class="headerlink" title="从Git拉取代码并初始化程序环境"></a>从Git拉取代码并初始化程序环境</h2><h3 id="拉取代码"><a href="#拉取代码" class="headerlink" title="拉取代码"></a>拉取代码</h3><p>将代码上托管在Github上，并在远程服务器上通过git拉取项目代码，是比较方便的一种方式：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="comment"># 你打算存放项目代码的目录路径</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> <span class="comment"># 你的项目仓库地址</span></span></span><br></pre></td></tr></table></figure><h3 id="初始化程序环境"><a href="#初始化程序环境" class="headerlink" title="初始化程序环境"></a>初始化程序环境</h3><p>项目通过工厂函数创建程序实例，在<code>项目根目录/__init__.py</code>中，使用<code>click</code>注册了多个初始化用的命令行命令，依次执行它们：</p><ol><li><p>初始化数据库：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> flask initdb</span></span><br></pre></td></tr></table></figure></li><li><p>初始化项目管理员：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> flask init</span></span><br></pre></td></tr></table></figure></li><li><p>生成虚拟填充数据：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> flask forge</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="配置并使用Gunicorn运行程序"><a href="#配置并使用Gunicorn运行程序" class="headerlink" title="配置并使用Gunicorn运行程序"></a>配置并使用Gunicorn运行程序</h2><p>Gunicorn运行一个WSGI程序时，使用的命令模式：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gunicorn [OPTION] 模块名:变量名</span></span><br></pre></td></tr></table></figure><p>这里的变量名即要运行的WSGI可调用对象,也就是我们使用Flask 创建的程序实例,而模块名即包含程序实例的模块，在本篇文章中，模块名即<code>wsgi</code>，变量名即<code>app</code>。</p><p>常用的几个<code>OPTION</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-k # 指定worker类，默认为同步worker，可采用异步worker，如：gevent、eventlet、tornado，但需要另外安装</span><br><span class="line">-w # 指定worker的数量，“通常来说，worker的数量建议为(2×CPU核心数)+1“</span><br><span class="line">-b # 指定绑定服务器套接字，如：gunicorn -b 127.0.0.1:8000 模块名:变量名</span><br><span class="line">-c # 指定配置文件路径，路径为字符串格式，如：gunicorn -c gun.conf</span><br></pre></td></tr></table></figure><p>以下是本次部署时使用的配置文件<code>gun.conf</code>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gun.conf</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">bind = <span class="string">'127.0.0.1:8000'</span> <span class="comment"># 绑定的ip及端口号</span></span><br><span class="line">workers = <span class="number">2</span> <span class="comment">#进程数</span></span><br><span class="line">worker_class = <span class="string">"gevent"</span> <span class="comment"># 使用gevent模式，还可以使用sync模式，默认的是sync模式</span></span><br><span class="line">debug = <span class="literal">True</span> <span class="comment"># 开启debug项后，在启动gunicorn的时候可以看到所有可配置项的配置</span></span><br><span class="line">chdir = <span class="string">''</span> <span class="comment"># 项目的根目录</span></span><br><span class="line">proc_name = <span class="string">'gunicorn.proc'</span> <span class="comment"># 设置进程名字</span></span><br></pre></td></tr></table></figure><p>因此，使用<strong>gunicorn</strong>运行时：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gunicorn -c gun.conf wsgi:app</span></span><br></pre></td></tr></table></figure><blockquote><p>更多gunicorn的配置参数，可以查看<a href="https://www.cnblogs.com/nanrou/p/7026789.html" target="_blank" rel="noopener">博客</a>。</p></blockquote><h2 id="使用Nginx提供反向代理"><a href="#使用Nginx提供反向代理" class="headerlink" title="使用Nginx提供反向代理"></a>使用Nginx提供反向代理</h2><p>在前面的步骤中，我们已经安装了Nginx，现在对其进行配置。</p><p>先说明一下安装好后的文件位置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;sbin&#x2F;nginx：主程序</span><br><span class="line">&#x2F;etc&#x2F;nginx：存放配置文件</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;nginx：存放静态文件</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;nginx：存放日志</span><br></pre></td></tr></table></figure><blockquote><p>我们可以在Nginx的默认配置文件(/etc/nginx/nginx.conf)中写入程序配置,但通常情况下,为了便于组织,我们可以在/etc/nginx/sites- enabled/或是/etc/nginx/conf.d/目录下为我们的Flask程序创建单独的Nginx 配置文件。</p><p><strong>– 《Flask Web开发实战》</strong></p></blockquote><p>Nginx配置的常用指令，见图：</p><p><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-13-184130.png" alt="Nginx配置的常用指令"></p><blockquote><p>其他的语法规则包括:块通过花括号“{}”指定;每一行指令以“;”结尾;以“#”开头的是注释。</p></blockquote><p>以下是本次部署使用的nginx的具体配置：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>; <span class="comment"># 监听80端口</span></span><br><span class="line">    <span class="attribute">server_name</span>  your_ip; <span class="comment"># HOST机器的外部域名，用地址也行</span></span><br><span class="line">    <span class="comment"># 未设置日志，所以这里先不进行配置</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:8000; <span class="comment"># 转发地址, 即Gunicorn运行的地址</span></span><br><span class="line">        <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：Nginx安装后会自动运行，可以通过访问服务器的IP地址，会看到Nginx提供的测试页面。</p></blockquote><h2 id="配置并使用Supervisor管理进程"><a href="#配置并使用Supervisor管理进程" class="headerlink" title="配置并使用Supervisor管理进程"></a>配置并使用Supervisor管理进程</h2><blockquote><p>安装Supervisor后,它会自动在/etc/supervisor目录下生成一个包含全局配置的配置文件,名为supervisord.conf的配置文件(INI风格语法) 来定义进程相关的命令等信息。</p><p>为了便于管理,我们可以为程序配置创建单独的配置文件。这个全局配置默认会将/etc/supervisor/conf.d目录下的配置文件也包含在全局配置文件中。</p><p><strong>– 《Flask Web开发实战》</strong></p></blockquote><p>本次部署，我们先备份<code>/etc/supervisor/conf.d/default</code>，再对其进行编辑：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> xthonblog.conf</span></span><br><span class="line">[program:xthonblog]</span><br><span class="line">environment=PYTHONPATH=$PYTHONPATH:/root/.pyenv/versions/blog-v377/bin/  ; 指定程序使用的python环境</span><br><span class="line">directory=/root/projects/2020/xthonblog  ; 程序的启动目录</span><br><span class="line">command=/root/.pyenv/versions/blog-v377/bin/gunicorn -c /root/projects/2020/xthonblog/gun.conf wsgi:app  ; 启动命令</span><br><span class="line">user=root         ; 用哪个用户启动</span><br><span class="line">autostart=true    ; 在 supervisord 启动的时候也自动启动</span><br><span class="line">autorestart=true  ; 自动重启</span><br><span class="line">stopasgroup=true  ; 与killasgroup一同开启，确保在关闭程序时停止所有相关的子进程</span><br><span class="line">killasgroup=true  ; 通过这两项配置来确保所有子进程都能正确停止</span><br><span class="line">stdout_logfile_maxbytes=5MB  ; stdout 日志文件大小</span><br><span class="line">stdout_logfile_backups=2     ; stdout 日志文件备份数</span><br><span class="line">stdout_logfile=/root/projects/2020/xthonblog/supervisor-log/xthon_stdout.log  ; stdout输出路径</span><br><span class="line">stderr_logfile=/root/projects/2020/xthonblog/supervisor-log/xthon_stderr.log  ; stderr输出路径</span><br></pre></td></tr></table></figure><p>其中 <code>[program:usercenter]</code> 中的 <code>usercenter</code> 是应用程序的唯一标识，不能重复。对该程序的所有操作（start, restart 等）都通过名字来实现。</p><p>如果python环境没有配置正确(包括gunicorn的路径、配置文件路径等)，supervisor启动时，会出现<code>FATAL、BACKOFF</code>等错误；</p><p><strong>有两种方式指定程序使用的 Python 环境：</strong></p><ol><li><code>command</code> 使用绝对路径。本项目使用 pyenv 来管理 Python 环境，上面例子中的 gunicorn 路径可以替换为 <code>/root/.pyenv/versions/blog-v377/bin/gunicorn</code>. 这种方式一目了然，推荐使用。</li><li>通过 <code>environment</code> 配置 <code>PYTHONPATH</code>.<br>如<code>xthonblog.conf</code>中那样，这个配置项非常有用，可以用来给程序传入环境变量。</li></ol><p>编辑完后通过下面的命令重新启动supervisor服务以便让配置生效:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo service supervisor restart</span></span><br></pre></td></tr></table></figure><p>配置中的xthonblog程序会在后台被自动执行，可以通过supervisor提供的命令行工具supervisorctl来查看和操作相关程序：</p><p><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-13-192120.png" alt="supervisor-RUNNING运行状态"></p><p>可以看到，程序已经在运行了，现在通过访问远程服务器的IP地址，即可成功访问项目页面。</p><blockquote><p>除了命令行工具supervisorctl,Supervisor还提供了Web客户端，这里就不进一步说明了。</p></blockquote><hr><p>感谢阅读～٩(๑òωó๑)۶</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>踩坑日记</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>flask</tag>
        <tag>pyenv</tag>
        <tag>gunicorn</tag>
        <tag>nginx</tag>
        <tag>supervisor</tag>
        <tag>git</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title>[Mac] vscode更新失败的解决方法</title>
    <url>/posts/19849/</url>
    <content><![CDATA[<!-- build time:Fri Apr 24 2020 22:36:20 GMT+0800 (中国标准时间) --><p>记录Mac系统下，vscode更新失败，提示<code>Permission denied</code>的解决办法。</p><p>vscode版本：<code>1.44.0</code></p><a id="more"></a><h2 id="错误提示"><a href="#错误提示" class="headerlink" title="错误提示"></a>错误提示</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Could not create temporary directory: Permission denied</span><br></pre></td></tr></table></figure><h2 id="问题起因"><a href="#问题起因" class="headerlink" title="问题起因"></a>问题起因</h2><p>在 <code>/Users/username/Library/Caches/</code>目录下，有以下两个文件， 对应的用户是不一样的，一个是<code>root</code>一个<code>username</code>，因为这两个文件的用户不一样，导致了更新失败。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li><p>关闭vscode</p></li><li><p>输入：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 这一步是需要输入密码的</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo chown <span class="variable">$USER</span> ~/Library/Caches/com.microsoft.VSCode.ShipIt/</span></span><br></pre></td></tr></table></figure></li><li><p>输入：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 这一步是不需要输入密码的, 如果不进行第一步，第二步会报错</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo chown <span class="variable">$USER</span> ~/Library/Caches/com.microsoft.VSCode.ShipIt/*</span></span><br></pre></td></tr></table></figure></li><li><p>更新xattr：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> xattr -dr com.apple.quarantine /Applications/Visual\ Studio\ Code.app</span></span><br></pre></td></tr></table></figure></li><li><p>重新打开vscode，点击Code &gt; Check for Updates， 点击之后，<code>Check for Updates</code>变成灰色，需要稍等片刻，便可以更新，之后会跳出提示，重启vscode，再次重启vscode，问题就解决了。</p></li></ol><blockquote><p>参考 <code>Code won&#39;t update on macOS #7426</code> ，问题链接地址：<a href="https://github.com/Microsoft/vscode/issues/7426" target="_blank" rel="noopener">vscode-issue-7426</a></p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>踩坑日记</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>vscode</tag>
        <tag>解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title>使用正则表达式筛选日志中的表名或SQL语句</title>
    <url>/posts/8182/</url>
    <content><![CDATA[<!-- build time:Sat Apr 25 2020 12:07:09 GMT+0800 (中国标准时间) --><p>近几天收到学弟的求助，具体是关于从日志中筛选数据的，帮忙写了几则正则，总结记录一下。</p><a id="more"></a><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ol><li><p>一开始的要求：</p><blockquote><p>在日志文件中，一行为一条日志记录，从这些日志中，筛选出SQL语句涉及到的表名。</p></blockquote></li><li><p>修改后的要求：</p><blockquote><p>从日志中，筛选SQL语句</p></blockquote></li></ol><h2 id="编写正则表达式"><a href="#编写正则表达式" class="headerlink" title="编写正则表达式"></a>编写正则表达式</h2><p>首先看一下日志格式：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Info <span class="number">2020</span><span class="number">-04</span><span class="number">-19</span> <span class="number">20</span>:<span class="number">02</span>:<span class="number">36.114</span>+<span class="number">08</span>:<span class="number">00</span> logger.<span class="keyword">go</span>:<span class="number">81</span> <span class="number">10.11</span><span class="number">.39</span><span class="number">.230</span> ad.tetris.clue_binlog - <span class="keyword">default</span> canary lf <span class="number">0</span> _podName=dp<span class="number">-8</span>d1fdf3061-d474b99cc-hggd5 _language=<span class="keyword">go</span> _process=<span class="number">186</span> _msg=GORM LOG SQL:SELECT * FROM <span class="string">`instance_consult`</span>  WHERE (consult_id = <span class="string">'1663479833969672'</span>) LIMIT <span class="number">1</span> Cost:<span class="number">1.09</span>ms</span><br><span class="line">Info <span class="number">2020</span><span class="number">-04</span><span class="number">-19</span> <span class="number">20</span>:<span class="number">02</span>:<span class="number">36.144</span>+<span class="number">08</span>:<span class="number">00</span> logger.<span class="keyword">go</span>:<span class="number">81</span> <span class="number">10.11</span><span class="number">.39</span><span class="number">.230</span> ad.tetris.clue_binlog - <span class="keyword">default</span> canary lf <span class="number">0</span> _podName=dp<span class="number">-8</span>d1fdf3061-d474b99cc-hggd5 _process=<span class="number">186</span> _language=<span class="keyword">go</span> _msg=GORM LOG SQL:SELECT * FROM <span class="string">`clue`</span>  WHERE <span class="string">`clue`</span>.<span class="string">`clue_id`</span> = <span class="string">'1664399848891405'</span> ORDER BY <span class="string">`clue`</span>.<span class="string">`clue_id`</span> ASC LIMIT <span class="number">1</span> Cost:<span class="number">1.51</span>ms</span><br><span class="line">Info <span class="number">2020</span><span class="number">-04</span><span class="number">-19</span> <span class="number">20</span>:<span class="number">02</span>:<span class="number">36.149</span>+<span class="number">08</span>:<span class="number">00</span> logger.<span class="keyword">go</span>:<span class="number">81</span> <span class="number">10.11</span><span class="number">.39</span><span class="number">.230</span> ad.tetris.clue_binlog - <span class="keyword">default</span> canary lf <span class="number">0</span> _process=<span class="number">186</span> _podName=dp<span class="number">-8</span>d1fdf3061-d474b99cc-hggd5 _language=<span class="keyword">go</span> _msg=GORM LOG SQL:SELECT * FROM <span class="string">`instance_form`</span>  WHERE <span class="string">`instance_form`</span>.<span class="string">`instance_id`</span> = <span class="string">'1662691860828215'</span> ORDER BY <span class="string">`instance_form`</span>.<span class="string">`instance_id`</span> ASC LIMIT <span class="number">1</span> Cost:<span class="number">1.34</span>ms</span><br><span class="line">Info <span class="number">2020</span><span class="number">-04</span><span class="number">-19</span> <span class="number">20</span>:<span class="number">02</span>:<span class="number">36.144</span>+<span class="number">08</span>:<span class="number">00</span> logger.<span class="keyword">go</span>:<span class="number">81</span> <span class="number">10.11</span><span class="number">.39</span><span class="number">.230</span> ad.tetris.clue_binlog - <span class="keyword">default</span> canary lf <span class="number">0</span> _podName=dp<span class="number">-8</span>d1fdf3061-d474b99cc-hggd5 _process=<span class="number">186</span> _language=<span class="keyword">go</span> _msg=GORM LOG SQL:SELECT * FROM <span class="string">`clue`</span>, <span class="string">`test1`</span>, <span class="string">`test_table`</span>  WHERE <span class="string">`clue`</span>.<span class="string">`clue_id`</span> = <span class="string">'1664399848891405'</span> ORDER BY <span class="string">`clue`</span>.<span class="string">`clue_id`</span> ASC LIMIT <span class="number">1</span> Cost:<span class="number">1.51</span>ms</span><br></pre></td></tr></table></figure><p>正则我也是即用即学（不想记），Google上搜个<code>正则表达式30分钟教程</code>，随便一个点进去就行了。</p><p>开工！</p><h3 id="对应要求1的正则表达式"><a href="#对应要求1的正则表达式" class="headerlink" title="对应要求1的正则表达式"></a>对应要求1的正则表达式</h3><p>由于要得到表名（学弟说不考虑join的情况），那么一般就是<code>from table a, table b where</code>的情况了，考虑多表情况下，正则如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># apply only to "from ... where" situation</span></span><br><span class="line">regex = <span class="string">r"(\bFROM\s)+(`\w+`,?\s?)+(\s+\w?\sWHERE)+"</span></span><br></pre></td></tr></table></figure><p>加上<code>()</code>，分组捕获，由于这里没有多种情况，所以不考虑<strong>捕获分组或者非捕获分组</strong>，感兴趣的可以查看<a href="https://blog.csdn.net/Leonard_wang/article/details/79813425" target="_blank" rel="noopener">《正则之括号的捕获和非捕获属性》</a>这篇文章；</p><p>示例代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># apply only to "from ... where" situation</span></span><br><span class="line">regex = <span class="string">r"(\bFROM\s)+(`\w+`,?\s?)+(\s+\w?\sWHERE)+"</span></span><br><span class="line"><span class="comment"># Compile match pattern</span></span><br><span class="line">pattern = re.compile(regex) </span><br><span class="line"></span><br><span class="line">res = set()</span><br><span class="line"><span class="comment"># The file path is changed according to the situation</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"./log.txt"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        line = f.readline().replace(<span class="string">"\n"</span>, <span class="string">""</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># Just get the table name(or tables' name);</span></span><br><span class="line">        <span class="comment"># Because of the multi-table case, group(0) is used to get the entire matching string</span></span><br><span class="line">        find = re.search(regex, line).group(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> find:</span><br><span class="line">            find = find.replace(<span class="string">"FROM "</span>, <span class="string">""</span>).replace(<span class="string">"  WHERE"</span>, <span class="string">""</span>)</span><br><span class="line">            <span class="comment"># Multi-table situation: from table1, table2, table3 ... where</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">","</span> <span class="keyword">in</span> find:</span><br><span class="line">                names = find.split(<span class="string">", "</span>)</span><br><span class="line">                <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">                    res.add(name.replace(<span class="string">"`"</span>, <span class="string">""</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.add(find.replace(<span class="string">"`"</span>, <span class="string">""</span>))</span><br><span class="line"></span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><p>在这里解释一下，<code>find = find.replace(&quot;FROM &quot;, &quot;&quot;).replace(&quot; WHERE&quot;, &quot;&quot;)</code>这条语句，使用replace进行替换而非正则的<code>sub</code>，原因是：对于一般固定不变的常规字符串进行替换，使用replace速度最快；详情可自行查阅<code>python中replace与re.sub运行效率比较</code>。</p><h3 id="对应要求2的正则表达式"><a href="#对应要求2的正则表达式" class="headerlink" title="对应要求2的正则表达式"></a>对应要求2的正则表达式</h3><p>要求2仅要求筛选出SQL语句，并写入文件，那就更方便了，只要匹配以<code>SQL:</code>开头的日志记录即可，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">regex = <span class="string">r"(SQL:)(.+)(\sCost)"</span></span><br><span class="line"><span class="comment"># Compile match pattern</span></span><br><span class="line">pattern = re.compile(regex)</span><br><span class="line"></span><br><span class="line">res = set()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># The file path is changed according to the situation</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"./log.txt"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            line = f.readline().replace(<span class="string">"\n"</span>, <span class="string">""</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># Parenthesis is used for group capture and the 2th group is the SQL statement</span></span><br><span class="line">            find = pattern.search(line)</span><br><span class="line">            <span class="keyword">if</span> find:</span><br><span class="line">                res.add(find.group(<span class="number">2</span>))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">"Reason:"</span>, e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"./sql_statements.txt"</span>, <span class="string">"a"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> sql <span class="keyword">in</span> res:</span><br><span class="line">            f.write(sql)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">"Reason:"</span>, e)</span><br></pre></td></tr></table></figure><h2 id="意外状况"><a href="#意外状况" class="headerlink" title="意外状况"></a>意外状况</h2><p>要筛选出像这样的语句：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`id`</span> <span class="keyword">FROM</span> <span class="string">`form_element`</span>  <span class="keyword">WHERE</span> (<span class="keyword">id</span> = <span class="string">'13126454'</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">`id`</span> <span class="keyword">FROM</span> <span class="string">`form_element`</span>  <span class="keyword">WHERE</span> (<span class="keyword">id</span> = <span class="string">'13126418'</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">`id`</span> <span class="keyword">FROM</span> <span class="string">`form_element`</span>  <span class="keyword">WHERE</span> (<span class="keyword">id</span> = <span class="string">'13126429'</span>)</span><br></pre></td></tr></table></figure><p>不考虑key值，这类的语句仅保留一条。其实和要求1类似，稍微修改一下即可，正则规则如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(SELECT)\s(&#96;\w+&#96;.?\s?)+\s(FROM)\s(&#96;\w+.?\s?&#96;)+\s+(WHERE)\s+\(.+\)</span><br></pre></td></tr></table></figure><h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>本篇文章就到这里，感谢阅读。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>教程</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>正则表达式</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>[Hexo]为next主题的归档页面增加月份分类</title>
    <url>/posts/13214/</url>
    <content><![CDATA[<!-- build time:Fri Apr 24 2020 22:36:20 GMT+0800 (中国标准时间) --><p>今天的施工目标是：<strong>为归档页面增加月份分类</strong>！</p><p>废话不多说，马上进入正题。</p><a id="more"></a><h2 id="环境-Environments"><a href="#环境-Environments" class="headerlink" title="环境[Environments]"></a>环境[Environments]</h2><p>hexo下，即使是同一个主题，不同版本中的配置也不尽相同，因此在开始之前先介绍环境。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hexo:</span> <span class="number">4.2</span><span class="number">.0</span></span><br><span class="line"><span class="attr">next:</span> <span class="number">7.8</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p>自<code>next 7.4.0</code>开始，该主题就增加了<strong>定制代码注入</strong>的功能，但是我还没有去了解其自定义注入的方法，毕竟是刚刚从<code>next 5.x.x</code>升上来的（<del>明明就是懒</del>），所以这里还是先介绍一下通过修改主题文件的方式来达到增添月份分类的效果。</p><h2 id="在渲染模版中增加月份分类的标签"><a href="#在渲染模版中增加月份分类的标签" class="headerlink" title="在渲染模版中增加月份分类的标签"></a>在渲染模版中增加月份分类的标签</h2><p>首先打开<code>theme/next/layout/_macro/post-collapse.swig</code>，观察一下：</p><p><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-17-090305.png" alt=""></p><p>这一段代码，渲染了归档页面的<strong>年份</strong>一栏，通过这个逻辑，我们只需要照猫画虎即可：</p><p><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-17-090609.png" alt=""></p><p>简单解释一下：</p><ul><li><p><code>set current_month = &#39;0&#39;</code>即初始化了一个<code>current_month</code>变量，便于下方进行判断渲染。</p></li><li><p><code>set month = date(post.date, &#39;MMM&#39;)</code>，获取文章的月份，并按照 <code>MMM</code> 的格式进行转换，对于这个格式不太清楚的，可以查看 <code>momentjs</code> 插件的<a href="https://momentjs.com/docs/" target="_blank" rel="noopener">官方文档</a>。</p></li><li><p>第<strong>13</strong>行的 <code>set current_month = &#39;0&#39;</code> ，作用是“重置初始月份”——每生成一个年份分类后，继而渲染月份分类，随后是符合该年月的文章，如果不重置月份的话，下一个年份如果有相同的月份的文章，就无法渲染出月份标签，因为此时 <code>current_month = month</code>，情况如图：</p><p><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-17-092249.png" alt=""></p></li></ul><h2 id="配置月份分类的样式"><a href="#配置月份分类的样式" class="headerlink" title="配置月份分类的样式"></a>配置月份分类的样式</h2><p>在上一步中，我们添加了月份分类，光是这样还不够，它还得有相应的样式呀，下面我们就来配置它的样式～</p><ol><li><p>打开<code>themes/next7/source/css/_common/components/post/post-collapse.styl</code> ；</p></li><li><p>查找 <code>.collection-year</code> ，这是年份分类的样式；</p></li><li><p>还记得我们在上一步中给月份分类标签定义的属性吗：<code>class=&quot;collection-header&quot;</code> ，现在我们在年份分类样式的后面加上以下代码：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.collection-month</span> &#123; <span class="comment">//属性不一定是这个名字，具体和你在swig文件中为其配置的class值有关，照着它来</span></span><br><span class="line">  <span class="attribute">font-size</span>: <span class="variable">$font</span>-size-largest;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">60px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line"></span><br><span class="line">  &amp;::before &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="variable">$grey</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">' '</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">8px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么？你说这和年份的样式一样？！咳咳…是没错，要好康的、要动画你再自己改嘛。</p><p>设置完后的效果，看看我的<a href="http://xthon.cn/archives/">归档页面</a>就知道啦。</p><p>更棒的样式，可以参考<strong>shioko</strong>的<a href="https://co5.me/archives/" target="_blank" rel="noopener">归档页面</a>~ 大声地说：这次施工也是参考了<strong>shioko</strong>的<a href="https://co5.me/2018/180613-date.html" target="_blank" rel="noopener">文章</a>进行的哦～</p></li></ol><h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>好啦，今天的活就到这里，收工！感谢你的阅读！٩(๑òωó๑)۶</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next主题</tag>
        <tag>美化</tag>
      </tags>
  </entry>
  <entry>
    <title>[Python]运用requests库进行简单的爬取</title>
    <url>/posts/47992/</url>
    <content><![CDATA[<!-- build time:Fri Apr 24 2020 22:36:20 GMT+0800 (中国标准时间) --><p>学习了requests的基本方法后，我很想练练手，嘿嘿，马上就来试试看，来写个超级无敌hin简单的小爬虫吧~</p><a id="more"></a><h2 id="单个抓取的小爬虫"><a href="#单个抓取的小爬虫" class="headerlink" title="单个抓取的小爬虫"></a>单个抓取的小爬虫</h2><p>我常常在网上看到很多很好看的图片，我一般都是“右键-另存为”；可是呀，几十张还好，如果是几百张，几千张，我该怎么办呢？？</p><p><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-17-102229.jpg" alt=""></p><p>之前的我，这个时候一般就会去找别人打包好的压缩图包，可是他们又是怎么获取的呢？？肯定不会是“右键-另存为”这样一张张地操作啦~（可能有些人还真是这样做的）</p><p>开始学习爬虫之后，就可以用爬虫来抓取图片啦！一开始，先来学抓取单张图片吧～</p><ol><li>先导入 requests 与 os</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure><ol start="2"><li><p>设置图片存取路径</p><p>先提供一个url吧！</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">""</span>   <span class="comment">#双引号里填写你要抓取的图片地址~</span></span><br><span class="line">root = <span class="string">"E://pics//"</span></span><br><span class="line">path = root + url.split(<span class="string">'/'</span>)[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p><strong>root</strong>当然是设置存放图片的文件夹的路径啦~</p><p>那么<strong>path</strong>是什么呢？ 嘿嘿，别急，听我说，<code>url.split(&#39;/&#39;)[-1]</code>这个小伙伴都看出来了吧？作用就是切取图片的<strong>原名称</strong>咯~ 文件夹路径加上原名称，自然就是按原名称存放图片到我们设定的文件夹里啦~ 当然，<strong>root</strong>是可变的<del>名称你也可以照你喜欢的来</del>o(* ￣▽￣*)ブ</p></li></ol><h2 id="编写异常处理的代码"><a href="#编写异常处理的代码" class="headerlink" title="编写异常处理的代码"></a>编写异常处理的代码</h2><p>这个无论什么时候都十分重要！！！</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(root):</span><br><span class="line">        os.mkdir(root)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">        r = requests.get(url)</span><br><span class="line">        <span class="keyword">with</span> open(path,<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(r.content)</span><br><span class="line">            f.close</span><br><span class="line">            print(<span class="string">"文件保存成功"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"文件已经存在"</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"爬取失败"</span>)</span><br></pre></td></tr></table></figure><h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>把以上的代码按次序组合起来，就是单张图片抓取的小爬虫啦！</p><p>当然，你可以把它写成函数，然后通过循环不断调用，只不过每一次都需要你提交一份url啦……</p><p>虽然看起来还很蠢笨，不过，通过它，我大概了解到了抓取图片的机制啦，那你呢？不要吐槽那只小爬虫啦，快快理解它才是最重要的，对不对？？</p><p><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-17-101910.jpg" alt=""></p><p>我好菜啊……<strong>就先写到这里…つ﹏⊂</strong> 再见～</p><p><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-17-101912.gif" alt=""></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>魔法师成长日记</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>requests</tag>
      </tags>
  </entry>
  <entry>
    <title>[Python]初识网络爬虫</title>
    <url>/posts/24312/</url>
    <content><![CDATA[<!-- build time:Fri Apr 24 2020 22:36:20 GMT+0800 (中国标准时间) --><p>嗯，是跟着mooc的视频学的。</p><p>觉得看完一部分就该记下来自己学了啥。</p><p>好啦，这是魔法师成长日记的第一篇文章~(●ˇ∀ˇ●)</p><a id="more"></a><h2 id="环境准备-Enviornments"><a href="#环境准备-Enviornments" class="headerlink" title="环境准备[Enviornments]"></a>环境准备[Enviornments]</h2><ol><li>安装python3</li><li>安装pip</li><li>安装requests库</li></ol><p>安装requests库（cmd命令行下）：</p><p><code>pip install requests</code></p><p>是不是很简单？？o(*￣▽￣ *)ブ</p><h2 id="Try-to-do"><a href="#Try-to-do" class="headerlink" title="Try to do"></a>Try to do</h2><blockquote><p>先来拿百度试试手吧~<br>首先打开python的ide：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">r &#x3D; requests.get(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;)</span><br><span class="line">r.encoding &#x3D; r.apparent_encoding</span><br><span class="line">r.text</span><br></pre></td></tr></table></figure><p>好啦，这时候你会看到一堆数据显示在你的窗口上~<br>像这样：<br><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-17-100444.png" alt="example"></p><p>呐，那些数据就是你从百度首页上爬下来的东东啦~<br>是你第一个手动完成的最简单的一个爬虫哦~(●ˇ∀ˇ●)</p><p><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-17-100530.jpg" alt="pride"></p><h2 id="Go-forward"><a href="#Go-forward" class="headerlink" title="Go forward"></a>Go forward</h2><p>不过呢，有时候还是会碰见一些无法访问网页的情况吧？这时候我们怎么处理呢？<br>我们可以在cmd中输出 <code>r.status_code</code> 的值来看，如果返回值不是200的话，意味着你访问失败啦。</p><p>但是，那是在命令行中的办法，如果在程序中，我们该肿么办？<br>可以这样：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetHtmlText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url,timeout = <span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"产生异常"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    url = <span class="string">"http://www.baidu.com"</span></span><br><span class="line">    print(GetHtmlText(url))</span><br></pre></td></tr></table></figure><p>(当然啦，一般 <code>exception</code> 还是要精准捕获异常的，这里是简单的示范啦 )</p><p>如果你用的是vscode的话，且恰好安装了python插件的话，直接右键 <strong>Run Python File in Terminal</strong> 就可以看到运行结果咯~是不是发现跟第一个例子中输出的数据是一样的呀？</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>现在，给出requests库的常用的六个基础方法吧~</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">requests.request()</span><br><span class="line">requests.get()</span><br><span class="line">requests.head()</span><br><span class="line">requests.post()</span><br><span class="line">requests.patch()</span><br><span class="line">requests.put()</span><br><span class="line">requests.delete()</span><br></pre></td></tr></table></figure><p>是不是很好奇这些命令都能做些什么呢？去翻翻看requests的<a href="https://requests.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">文档</a>吧~</p><p>好啦，这就是本篇文章的全部内容啦～感谢你的阅读～</p><p>See you then~</p><p><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-17-101015.jpg" alt="再见"></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>魔法师成长日记</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10下利用github+hexo搭建博客</title>
    <url>/posts/50967/</url>
    <content><![CDATA[<!-- build time:Fri Apr 24 2020 22:36:20 GMT+0800 (中国标准时间) --><p>写在前面：这两天折腾了好一会才将博客搭好，期间查了不少资料看了不少大大的博文，受益匪浅~所以将其总结一下，也为能看到的小伙伴们做个借鉴用吧 φ(゜▽゜*)♪”</p><a id="more"></a><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul><li>win10 64位系统</li><li>Node.js</li><li>Git</li><li><a href="http://pan.baidu.com/s/1pKEKE63" target="_blank" rel="noopener">下载地址</a>，提取码：<code>9uyd</code> (有Git和Node.js的包)</li></ul><h2 id="安装Node-js和Git"><a href="#安装Node-js和Git" class="headerlink" title="安装Node.js和Git"></a>安装Node.js和Git</h2><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>一路点默认即可。。。O(∩_∩)O<br>安装完成后添加Path环境变量，使npm命令生效~</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:\Program Files\nodejs\node_modules\npm</span><br></pre></td></tr></table></figure><p>至于PATH环境变量：<br>在桌面，找到<strong>此电脑</strong> ，右键，点击<strong>属性</strong>，然后再在右边栏点击高级系统设置，点击右下方 <strong>环境变量</strong>，在下方框框<strong>系统变量</strong>那找到PATH，点击<strong>编辑</strong>，<strong>新建</strong>即可添加~</p><p>安装完后在cmd中分别输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>如果显示了版本号，就说明安装好啦~</p><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>进入Git的安装界面，如图：<br><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-13-192740.jpg" alt="Git-install"><br>大部分设置都只需要保持默认就好啦，但是为了操作方便，我们把PATH选项按照下图选择：<br><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-13-192844.jpg" alt="Git-PATH-Setting"></p><blockquote><p>这是对上图的解释，不需要了解请直接跳过 Git的默认设置下，出于安全考虑，只有在Git Bash中才能进行Git的相关操作。按照上图进行的选择，将会使得Git安装程序在系统PATH中加入Git的相关路径，使得你可以在CMD界面下调用Git，不用打开Git Bash了。</p><footer><strong>Xuanwo's Blog</strong></footer></blockquote><h2 id="Github部分"><a href="#Github部分" class="headerlink" title="Github部分"></a>Github部分</h2><h3 id="注册Github账号"><a href="#注册Github账号" class="headerlink" title="注册Github账号"></a>注册Github账号</h3><p>如果已经拥有账号，请跳过此步~(●’◡’●)</p><p>点击<a href="http://wiki.jikexueyuan.com/project/github-basics/sign-up.html" target="_blank" rel="noopener">教程</a>，按照教程里的步骤注册Github账户~<br>然后前往自己刚才填写的邮箱，点开Github发送给你的注册确认信，确认注册，结束注册流程。<br><strong>一定要确认注册，否则无法使用gh-pages！</strong></p><h3 id="创建与账号同名的Repository"><a href="#创建与账号同名的Repository" class="headerlink" title="创建与账号同名的Repository"></a>创建与账号同名的Repository</h3><p>登陆之后，点击页面右上角的加号，选择New repository：<br><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-13-192932.jpg" alt="Github-new-repository"><br>在Repository name下填写yourname.github.io，Description (optional)下填写一些简单的描述（不写也没有关系），如图所示：<br><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-13-193009.jpg" alt="Github-repository"><br><strong>注意！！！yourname.github.io里的yourname要与图里的 / 前的Github的用户名一致</strong></p><p>正确创建之后，将会看到如下界面（之前的图已经没了，就可耻的盗用一下网上的图片）：<br><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-13-193058.jpg" alt="Github-new-repo-look-like"></p><h3 id="开启gh-pages功能"><a href="#开启gh-pages功能" class="headerlink" title="开启gh-pages功能"></a>开启gh-pages功能</h3><p>点击界面右侧的Settings，你将会打开这个库的setting页面，向下拖动，直到看见GitHub Pages，如图：<br><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-13-193140.jpg" alt="Github-pages"><br>点击Automatic page generator，Github将会自动替你创建出一个gh-pages的页面。 如果你的配置没有问题，那么大约15分钟之后，yourname.github.io这个网址就可以正常访问了~ 如果yourname.github.io已经可以正常访问了，那么Github一侧的配置已经全部结束了。</p><hr><h2 id="部署Hexo"><a href="#部署Hexo" class="headerlink" title="部署Hexo"></a>部署Hexo</h2><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>在我的电脑中建立一个名字叫「Hexo」的文件夹，然后在此文件夹中右键打开Git Bash，输入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>执行完成后hexo就安装成功了<br>第一步结束，环境配置完毕可以开始创建自己的博客了<br>如果出现错误，可能要换一下源，输入下列命令后应该就可以了~ つ﹏⊂</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set registry&#x3D;&quot;http:&#x2F;&#x2F;registry.cnpmjs.org&quot;</span><br></pre></td></tr></table></figure><p>可能你会看到一个WARN，但是不用担心，这不会影响你的正常使用~然后输入:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure><p>随后窗口会刷出一大堆的白字，然后你在cmd里输入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><p>如果看到像下图一样的文字：<br><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-13-193239.jpg" alt="Hexo-Version"><br>就说明安装成功啦<del>~</del>(～￣▽￣)～</p><h3 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h3><p>接着上面的，输入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>（没有这一步后的截图啦，再次可耻地拿一张网上的给大家看看）如图：<br><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-13-193320.jpg" alt="hexo-init"><br>随后输入（安装依赖包）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>安装依赖包<br>Hexo随后会自动在目标文件夹建立网站所需要的所有文件~<br>请耐心等待哦 ^_-~</p><h3 id="体验Hexo"><a href="#体验Hexo" class="headerlink" title="体验Hexo"></a>体验Hexo</h3><p>继续，来，我们输入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>或者:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><p>这会生成<strong>静态页面至public目录（静态博客就在这个位置）</strong><br>你会看到一些字符刷刷的出来（只要不是提示错误就好啦b（￣▽￣）d　）<br>然后输入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>或者:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>这会：<br><strong>开启预览访问端口（默认端口4000，在bash窗口执行’ctrl + c’会关闭server）</strong><br>执行正常的话，应该会看到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO  Hexo is running at http:&#x2F;&#x2F;0.0.0.0:4000&#x2F;. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>这样的东西<br>接着，我们只需要在浏览器中打开<a href="http://localhost:4000/" target="_blank" rel="noopener"></a>，就可以看到：<br><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-13-193404.jpg" alt="hexo-first-time"><br>好啦，到这里，Hexo在本地的配置就已经全都结束啦<del>~</del>o(<em>￣▽￣</em>)ブ</p><hr><h2 id="部署Hexo到Github-Pages"><a href="#部署Hexo到Github-Pages" class="headerlink" title="部署Hexo到Github Pages"></a>部署Hexo到Github Pages</h2><h3 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h3><p>到这一步，我们还需要进行一些配置，以确保确保Hexo生成的页面能够正常的上传到Github(commit)。</p><h4 id="git-ssh-配置和使用"><a href="#git-ssh-配置和使用" class="headerlink" title="git-ssh 配置和使用"></a>git-ssh 配置和使用</h4><ol><li><p>设置Git的user name和email：(如果是第一次的话)<br>Git Bash下输入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name  &quot;你的Github用户名&quot;</span><br><span class="line">git config --global user.email &quot;你Github注册的邮箱&quot;</span><br></pre></td></tr></table></figure></li><li><p>生成密钥<br>在你想要存放密钥的文件夹下，打开Git Bash<br>输入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你Github注册的邮箱&quot;</span><br></pre></td></tr></table></figure><p>连续3个回车。如果不需要密码的话。<br>最后得到了两个文件：<strong>id_rsa</strong> 和 <strong>id_rsa.pub。</strong><br>在图形界面下打开文件夹找到上面两个文件，右键，以记事本方式打开id_rsa.pub<br>复制里面的公钥，然后打开<a href="https://github.com" target="_blank" rel="noopener"></a>，打开Settings，找到 SSH and GPG keys<br>添加一个进去：<br><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-13-193447.jpg" alt="Git-ssh_and_gpg"><br>点击<strong>New SSH Key</strong><br><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-13-193518.jpg" alt="Github_ssh_newkey"><br>在<strong>Title</strong>处输入一个你记得住的名字<br>在<strong>Key</strong>处将你复制的公钥粘贴进去<br>好了之后点击<strong>Add SSH Key</strong>添加公钥</p><blockquote><p>（别问我为什么我的那个钥匙图标是绿的…你的key用过一次之后也会变绿的…）</p><footer><strong>Matsuyoi ——Shiratsuyu</strong></footer></blockquote><p>随后，在你的Hexo的目录下，找到<strong>_config.yml</strong>文件，右键记事本方式打开，<br>拉到下方，可以看到<br><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-13-193554.jpg" alt="Github_Deployment"><br>有这么一行东西，我们在它下方加入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:yourname&#x2F;yourname.github.io.git   </span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>注意！！！</p></li></ol><p><strong>type：git后面不能有空格</strong><br><strong>”type：”之后请空一格。就是一格，不多不少</strong><br><strong>deploy：的下面三行一定要缩进两个空格！！！</strong><br>这里<strong>repo：</strong>后面的链接可以从Github上你的存储库那儿，<br>有一个SSH的栏，后面跟着链接，将其复制下来替换掉这儿的就好<br>（直接将这儿的复制进去再改不容易出错哦~）<br>然后，在Git Bash下执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>来安装所需的插件。<br>然后：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>开始上传<br>然后就可以通过<a href="http://yourname.github.io/" target="_blank" rel="noopener"></a>来访问自己刚刚上传的网站啦~<br>是不是很开心呢(●’◡’●)</p><p>最后附上一些常用命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000）</span><br><span class="line">hexo deploy #将.deploy目录部署到GitHub（这个下次讲w）</span><br><span class="line">hexo help # 查看帮助</span><br><span class="line">hexo version #查看Hexo的版本</span><br></pre></td></tr></table></figure><p>偷偷地：新建的文章保存在<strong>source/_post</strong>下哦~</p><hr><h2 id="在Github-Pages上绑定自己的域名"><a href="#在Github-Pages上绑定自己的域名" class="headerlink" title="在Github Pages上绑定自己的域名"></a>在Github Pages上绑定自己的域名</h2><blockquote><p>经过不懈的努力，我们终于可以通过github来访问自己的博客了。<br>但是github.io的域名总给人一种不上档次的感觉，<br>所以我们可以绑定自己的域名，通过自己的域名来访问博客。</p><footer><strong>Matsuyoi ——Shiratsuyu</strong></footer></blockquote><p>在blog\source中新建一个CNAME文件，将想要绑定的域名输入在里面，保存。<br>例如我想使用二级域名blog，就在文件中输入blog.matsuyoi.com。<br>登录你的域名服务台，在解析记录中添加一条CNAME记录，指向你的github.io地址：<br>（因为我自己用的还是Shiratsuyu的二级域名，所以这儿放他的图）：<br><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-13-193644.jpg" alt="build-hexo-3_3"><br>全部完成后，重新部署静态页面：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>这样，你就可以通过你自己的域名访问博客啦~O(∩_∩)O</p><hr><h2 id="Hexo-主题配置"><a href="#Hexo-主题配置" class="headerlink" title="Hexo 主题配置"></a>Hexo 主题配置</h2><p>有没有觉得默认的主题不太符合自己的口味呢？<br>不要慌不要慌ヽ（≧□≦）ノ<br>我们这就来更改主题~<br>可以在<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="noopener">此处</a>下载自己喜欢的主题<br>保存到<strong>Hexo</strong>目录下的<strong>themes</strong>文件夹下。<br>然后在<strong>hexo</strong>目录下的<strong>_config.yml</strong>文件中修改，记事本方式打开，拉到下方，如图：<br><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-13-193715.jpg" alt="themes_deploy"><br>注意：themes下主题的文件夹里也有个<strong>_config.yml</strong>，别改错了哟~(●ˇ∀ˇ●)</p><hr><p>感谢阅读～٩(๑òωó๑)۶</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>踩坑日记</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>windows</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac安装并配置MongoDB</title>
    <url>/posts/63714/</url>
    <content><![CDATA[<!-- build time:Fri Apr 24 2020 22:36:20 GMT+0800 (中国标准时间) --><p>简单介绍了通过Homebrew安装MongDB，并且为其进行简单配置的过程。</p><a id="more"></a><h2 id="Environment"><a href="#Environment" class="headerlink" title="[Environment]"></a>[Environment]</h2><ul><li>System: macOS 10.14.4</li><li>Terminal: zsh</li></ul><h2 id="更新Homebrew"><a href="#更新Homebrew" class="headerlink" title="更新Homebrew"></a>更新Homebrew</h2><p>首先更新一下homebrew(如果安装了的话)：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew update</span><br></pre></td></tr></table></figure><h2 id="安装MongoDB"><a href="#安装MongoDB" class="headerlink" title="安装MongoDB"></a>安装MongoDB</h2><p>直接使用homebrew安装即可：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install mongodb</span><br></pre></td></tr></table></figure><p>然后便稍等片刻吧。</p><h2 id="配置MongoDB"><a href="#配置MongoDB" class="headerlink" title="配置MongoDB"></a>配置MongoDB</h2><ol><li><p>指定MongoDB进程读写数据的目录。MongoDB默认使用<code>/data/db</code>目录来读写数据，因此此处直接在根目录下创建该文件夹：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /data/db</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>为<code>/data/db</code>文件夹授权：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将username替换为自己的用户名</span></span><br><span class="line">sudo chown username /data/db</span><br><span class="line"><span class="comment">#不知道自己用户名的使用如下命令查看</span></span><br><span class="line">whoami</span><br></pre></td></tr></table></figure></li><li><p>配置mongodb的环境变量<br>我使用的是zsh终端，所以此处先为zsh添加mongdb的安装路径；通过homebrew安装的软件，都被放置在<code>/usr/local/Celler/</code>下，不清楚的话，安装成功后会有提示：如下图：<br><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-12-094755.png" alt="mac-homebrew-install-mongodb-sucess"></p><p>命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc</span><br><span class="line"><span class="comment">#如果是使用bash终端，则：</span></span><br><span class="line">vim ~/.bash_profile</span><br><span class="line"><span class="comment">#添加mongodb的安装路径至zsh的path中</span></span><br><span class="line"><span class="comment">#在文件末尾使用添加下面的语句</span></span><br><span class="line"><span class="built_in">export</span> <span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/Cellar/mongodb/4.0.3_1/bin:<span class="variable">$&#123;PATH&#125;</span></span><br><span class="line"><span class="comment">#需要注意，此处的文件夹路径根据具体情况填写</span></span><br><span class="line"><span class="comment">#保存后，退出编辑文件，激活生效</span></span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>修改MongoDB的配置文件。<br>文件路径在安装成功时也提示给出：<br><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-12-094823.png" alt="mac-install-mongodb-config_location"></p><p>修改一下默认的配置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dbPath: /data/db</span><br></pre></td></tr></table></figure><p>保存并退出。</p></li></ol><ol start="5"><li><p>启动mongod服务：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongod</span><br></pre></td></tr></table></figure><p>成功启动则如下图：<br><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-12-094845.png" alt="mongodb-install-execute_mongod"></p><p>此时打开另一个终端输入mongo即可打开mongodb-client：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongo</span><br><span class="line"> <span class="comment">#显示当前数据库集合</span></span><br><span class="line"> show dbs</span><br></pre></td></tr></table></figure><p>如下图：<br><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-12-094901.png" alt="mongodb-show_dbs"><br>退出mongoldb-client：<br><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-12-094915.png" alt="mongodb-exit"></p></li></ol><hr><p>感谢阅读～٩(๑òωó๑)۶</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>教程</category>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>Web实验2碰到的问题</title>
    <url>/posts/28707/</url>
    <content><![CDATA[<!-- build time:Fri Apr 24 2020 22:36:20 GMT+0800 (中国标准时间) --><p>今日做web实验2，要求很简单，使用php接受html数据而已；但是完成过程中踩了不少坑，特此记录下来。</p><a id="more"></a><h2 id="Problems"><a href="#Problems" class="headerlink" title="[Problems]"></a>[Problems]</h2><ol><li>Apache配置php7错误;</li><li>phpstorm提交相关表单，出现 502 bad gateway;</li><li>phpstorm提交相关表单，出现 404 not found;</li><li>phpstorm提交相关表单，直接显示php源码，未解析;</li></ol><h2 id="Cause"><a href="#Cause" class="headerlink" title="[Cause]"></a>[Cause]</h2><ol><li>Apache的httpd.conf配置文件出错;</li><li>运行的php文件需要放在apache的网站根目录下，如果运行不在该目录下的文件就会显示502 bad gateway;</li><li>其次在运行相关表单提交或者php页面跳转时会提示404 not found，即找不到服务器。这是因为phpstorm的页面默认在localhost：63342端口下运行，而我们的apache服务器一般默认为80端口，所以在提交表单到服务器时它会找不到相关php程序，尽管你的路径是正确的，因此需要配置phpstorm的服务器环境;</li><li>网上查了许久，各种纷杂的原因，我都折腾了一遍，均未解决；以至于最后我解决了404、502的问题后，莫名其妙的可以解析了，所以我也不清楚原因;</li></ol><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="[Solutions]"></a>[Solutions]</h2><ol><li><p>打开terminal，如下操作：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc/apache2</span><br><span class="line"><span class="meta">#</span><span class="bash">open httpd.conf</span></span><br><span class="line">sudo vim httpd.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">然后找到LoadModule php7_module···这条语句</span></span><br><span class="line"><span class="meta">#</span><span class="bash">将其修改为你系统内的libphp7.so的路径,我使用了自带的，所以便只是将改语句句首的 <span class="comment"># 号去掉，变为：</span></span></span><br><span class="line">LoadModule php7_module libexec/apache2/libphp7.so</span><br></pre></td></tr></table></figure></li><li><p>将文件移动到Apache根目录下即可；</p></li><li><p>配置phpstorm：</p><p><code>preferences -&gt; Build,Excution,Deployment -&gt; Deployment</code> ，选择左上角绿色的“+”按钮新建，起个名字，type选择inplace（本地调试的意思），然后设置web sever root url为：<code>http://localhost</code></p><p>如图：</p><p><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-12-094953.png" alt="配置phpstorm-deployment"></p><p>然后在mappings标签页下填写localpath，即你的<strong>apache网站根目录</strong>，如图：</p><p><img data-src="https://hexo-image-gz-1252782802.cos.ap-guangzhou.myqcloud.com/blog-images/2020-04-12-095011.png" alt="配置phpstorm-deployment-mapping"></p></li><li><p>网上查找的几个点如：修改<code>/etc/php.ini.default</code>为<code>php.ini</code>、将<code>php.ini</code>中的<code>short_open_tag = Off</code>改为<code>short_open_tag = On</code>，再重启Apache(<code>sudo apachectl restart</code>)……</p></li></ol><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>踩坑日记</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>apache</tag>
        <tag>web</tag>
      </tags>
  </entry>
</search>
